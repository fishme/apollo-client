---
title: Key arguments in Apollo Client
description: Using the keyArgs API
sidebar_title: keyArgs
---

> We recommend reading [Core pagination API](./core-api) before learning about considerations specific to `keyArgs` configuration.

In Apollo Client, a **key argument** is any GraphQL argument that can cause a schema field to return a logically distinct value. For example, consider this `Query.user` field:

```graphql{3}
type Query {
  # Returns whichever User object corresponds to `id`
  user(id: ID!): User
}
```

In this example, `id` is a key argument for `Query.user`, because it influences _which_ `User` object is returned.

## Default behavior

By default, the Apollo Client cache considers _all_ GraphQL arguments to be key arguments, which affects how it stores data.

### Caching multiple values for a field

Key arguments enable a single schema field to return logically distinct values. Because of this, the Apollo Client cache needs to be able to _store_ multiple distinct values for a single field.

To accomplish this, the cache includes the values of a field's key arguments in the **storage key** it uses for that field:

```yaml:title=Cache
ROOT_QUERY
  __typename: "Query"

  user({"id":"1"}):
    __ref: "User:1"

  user({"id":"2"}):
    __ref: "User:2"
```

Here, we've queried for `User`s with `id`s `1` and `2`. The cache stores these values separately within the `user` field's containing object (`ROOT_QUERY`). Each value uses a storage key that includes both the field name _and_ key argument values.

> If a field has no key arguments, its storage key is just its name.

Again, the cache considers _all_ arguments to be key arguments by default. This means that it stores a separate value for _every possible argument combination a field supports_.

This default behavior is for safety: the cache doesn't know whether it can _merge_ the values returned for different argument combinations without invalidating important data. For example, the cache definitely _shouldn't_ merge the results of querying for `User`s with `id`s `1` and `2`.

### Pagination issues

Certain arguments _shouldn't_ cause the Apollo Client cache to store a separate value. This is almost always the case for arguments related to paginated lists.

Consider this `Query.feed` field:

```graphql{2}
type Query {
  feed(offset: Int, limit: Int, category: Category): [FeedItem!]
}
```

The `offset` and `limit` arguments enable a client to specify which "page" of the list it wants to fetch. In an app with an infinitely scrolling feed, the client might initially fetch the first ten items, then fetch the _next_ ten:

```graphql
# First query
query GetFeedItems {
  feed(offset: 0, limit: 10, category: "SPORTS")
}

# Second query
query GetFeedItems {
  feed(offset: 10, limit: 10, category: "SPORTS")
}
```

But as discussed [above](#caching-multiple-values-for-a-field), these two lists of ten items are cached _separately_ by default. This means that when the second query completes, the returned items _aren't_ appended to the original list in the feed!

```yaml:title=Cache
ROOT_QUERY
  __typename: "Query"

  feed({"offset":"0","limit":"10","category":"SPORTS"}):
    [...]

  feed({"offset":"10","limit":"10","category":"SPORTS"}):
    [...]
```

In this case, we _don't_ want `offset` and `limit` to be key arguments of the `Query.feed` field. Instead, the Apollo Client cache _should_ merge the results of the two above queries into a single cache entry that includes items from both lists.

To handle this case, we can [set key arguments](#setting-key-arguments) for the field.

## Setting key arguments

You can specify a particular field's key arguments by defining a [field policy](../caching/cache-field-behavior) for that field:

```js{5-7}
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        feed: {
          keyArgs: ["category"],
        },
      },
    },
  },
});
```

The field policy for `Query.feed` above includes a `keyArgs` array, which contains the names of all arguments that the cache _should_ treat as key arguments for the field.

In this case, we don't want the cache to treat `offset` or `limit` as key arguments, because those arguments don't change _which_ feed we're fetching from. However, we _do_ want to treat `category` as a key argument, because we want to store our `SPORTS` feed separately from other feeds, such as `FASHION`.

### Supported values for `keyArgs`

In addition to providing a flat array of argument names, you can provide any of the following values for `keyArgs`:

* `false`, if _none_ of the field's arguments should be treated as key arguments.
* An array that includes _nested_ argument names, if an argument is an `Input` type with its own fields (e.g., `["input-arg", ["nested-arg"]]`).
* A function that can sanitize and serialize the `args` object however you like before generating the field's storage key.
    * This is for advanced use cases. See [`FieldPolicy` API reference](../caching/cache-field-behavior/#fieldpolicy-api-reference).

In the unlikely event that a `keyArgs` array is insufficient to specify the storage key, you can alternatively pass a function for `keyArgs`, which allows you to sanitize and serialize the `args` object however you like.


## Which arguments belong in `keyArgs`?

Throughout this area of the documentation, you'll find a number of possible `keyArgs` configurations, ranging from including all arguments by default, to completely disabling argument-based field identification using `keyArgs: false`. To understand which arguments belong in `keyArgs` (if any), it's helpful to consider those two extremes first&mdash;including all arguments in the field key, or none of them&mdash;because those are the most common cases. Building on that understanding, we can then discuss the consequences of moving an individual argument into or out of `keyArgs`.

If you include all arguments in the field key, as `InMemoryCache` does by default, then every different combination of argument values will correspond to a different storage location for internal field data. In other words, if you change any argument values, the field key will be different, so the field value will be stored in a different location. In your `read` and `merge` functions, this internal field data is provided by the `existing` parameter, which will be undefined when a particular combination of arguments has never been seen before. With this approach, the cache can reuse field values only if the arguments exactly match, which significantly reduces the hit rate of the cache, but also keeps the cache from inappropriately reusing field values when differences in arguments actually matter.

On the other hand, if you configure your field with `keyArgs: false`, the field key will always be just the field name, without any extra characters appended to it. Because your `read` and `merge` functions have access to the field arguments via `options.args`, you could use `read` and `merge` to keep your internal data separated according to the arguments, simulating the behavior of `keyArgs` without actually using `keyArgs`. Your `read` function then gets to decide whether an existing field value can be reused, and how it should be transformed before it is reused, based on the runtime argument values and whatever internal value was previously stored.

For example, we could have used `keyArgs: false` instead of `keyArgs: ["type"]` for our `Query.feed` field policy:

```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        feed: {
          keyArgs: false,

          read(existing = {}, { args: { type, offset, limit }}) {
            return existing[type] &&
              existing[type].slice(offset, offset + limit);
          },

          merge(existing = {}, incoming, { args: { type, offset = 0 }}) {
            const merged = existing[type] ? existing[type].slice(0) : [];
            for (let i = 0; i < incoming.length; ++i) {
              merged[offset + i] = incoming[i];
            }
            existing[type] = merged;
            return existing;
          },
        },
      },
    },
  },
});
```

Instead of a single array, `existing` is now a map from `type`s to feeds, allowing a single field value to store multiple feed arrays, separated by `type`. However, this manual separation is logically equivalent to what would happen if you moved the `type` argument into `keyArgs` (using `keyArgs: ["type"]`, as above), so the extra effort is probably unnecessary. Assuming feeds with different `type` values have different data, and assuming our `read` function does not need simultaneous access to multiple feeds of different types, we can safely shift the responsibility for handling the `type` argument from the `read` and `merge` functions back to `keyArgs`, and simplify `read` and `merge` to handle only one feed at a time.

In short, if the logic for storing and retrieving field data is the same for different values of a given argument (like `type`), and those field values are logically independent from one another, then you probably should move that argument into `keyArgs`, to save yourself from having to deal with it in your `read` and `merge` functions.

By contrast, arguments that limit, filter, sort, or otherwise reprocess existing field data usually do not belong in `keyArgs`, because putting them in `keyArgs` makes field storage keys more diverse, reducing cache hit rate and limiting your ability to use different arguments to retrieve different views of the same data (without making a additional network requests).

As a general rule, `read` and `merge` functions can do almost anything with your field data, but there might be a less powerful tool (like `keyArgs`) that allows you to simplify (or avoid writing) custom `read` or `merge` functions. Whenever you have a choice between two capable tools, you should prefer the one that minimizes the total complexity of your code, which often favors a more limited, declarative API like `keyArgs`, over the unlimited power of functions like `merge` or `read`.

## The `@connection` directive

The `@connection` directive is a Relay-inspired convention that Apollo Client supports, though we now recommend `keyArgs` instead, because you can achieve the same effect with a single `keyArgs` configuration, whereas the `@connection` directive needs to be repeated in every query you send to your server.

In other words, whereas Relay encourages the following `@connection(...)` directive for `Query.feed` queries:
```js
const FEED_QUERY = gql`
  query Feed($type: FeedType!, $offset: Int, $limit: Int) {
    feed(type: $type, offset: $offset, limit: $limit) @connection(
      key: "feed",
      filter: ["type"]
    ) {
      edges {
        node { ... }
      }
      pageInfo {
        endCursor
        hasNextPage
      }
    }
  }
`;
```
in Apollo Client, you would typically use the following query (the same query without the `@connection(...)` directive):
```js
const FEED_QUERY = gql`
  query Feed($type: FeedType!, $offset: Int, $limit: Int) {
    feed(type: $type, offset: $offset, limit: $limit) {
      edges {
        node { ... }
      }
      pageInfo {
        endCursor
        hasNextPage
      }
    }
  }
`;
```
and instead configure `keyArgs` in your `Query.feed` field policy:
```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        feed: {
          keyArgs: ["type"],
        },
      },
    },
  },
})
```

If the `Query.feed` field does not have an argument like `type` that you can use in `keyArgs: [...]`, then it may make sense to use the `@connection` directive after all:
```js
const FEED_QUERY = gql`
  query Feed($offset: Int, $limit: Int, $feedKey: String) {
    feed(offset: $offset, limit: $limit) @connection(key: $feedKey) {
      edges {
        node { ... }
      }
      pageInfo {
        endCursor
        hasNextPage
      }
    }
  }
`;
```
If you execute this query with different values for the `$feedKey` variable, those feed results will be stored separately in the cache, whereas normally they would all be stored in the same list.

When choosing a `keyArgs` configuration for this `Query.feed` field, you should include the `@connection` directive as if it was an argument (the `@` tells `InMemoryCache` you mean a directive):
```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        feed: {
          keyArgs: ["@connection", ["key"]],
        },
      },
    },
  },
})
```

With this configuration, your cache will use a `feed:{"@connection":{"key":...}}` key rather than just `feed` to store separate `{ edges, pageInfo }` objects within the `ROOT_QUERY` object:
```js
expect(cache.extract()).toEqual({
  ROOT_QUERY: {
    __typename: "Query",
    'feed:{"@connection":{"key":"some feed key"}}': { edges, pageInfo },
    'feed:{"@connection":{"key":"another feed key"}}': { edges, pageInfo },
    'feed:{"@connection":{"key":"yet another key"}}': { edges, pageInfo },
    // ...
  },
})
```

The `["key"]` in `keyArgs: ["@connection", ["key"]]` means only the `key` argument to the `@connection` directive will be considered, and any other arguments (like `filter`) will be ignored. Passing just `key` to `@connection` is usually adequate, but if you are tempted to pass a `filter: ["someArg", "anotherArg"]` argument as well, you should instead include those argument names directly in `keyArgs`:
```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        feed: {
          keyArgs: ["someArg", "anotherArg", "@connection", ["key"]],
        },
      },
    },
  },
})
```
If any of these arguments or directives are not provided for the current query, they will be omitted from the field key automatically, without error. This means it is generally safe to include more arguments or directives in `keyArgs` than you expect to receive in all cases.

> As mentioned above, if a `keyArgs` array is insufficient to specify your desired field keys, you can alternatively pass a function for `keyArgs`, which takes the `args` object and a `{ typename, field, fieldName, variables }` context parameter, and can either return a string or return a dynamically-generated `keyArgs` array.

Although `keyArgs` (and `@connection`) are useful for more than just paginated fields, it's worth noting that `relayStylePagination` configures `keyArgs: false` by default. You can reconfigure this `keyArgs` behavior by passing an alternate value to `relayStylePagination`:
```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        feed: relayStylePagination(["type", "@connection", ["key"]]),
      },
    },
  },
})
```
In the unlikely event that a `keyArgs` array is insufficient to capture the identity of a field, remember that you can pass a function for `keyArgs`, which allows you to serialize the `args` object however you want.
